package main

import (
	"fmt"
	"godrunk/config"
	"log"
	"math/rand"
	"net/http"
	"time"

	"github.com/go-telegram-bot-api/telegram-bot-api"
)

type zupabot struct {
	*tgbotapi.BotAPI
}

type card struct {
	name        string
	description string
}

var cards = []*card{
	{"Я", "Этот бокал для тебя."},
	{"Ты", "Выбери, кто будет пить."},
	{"Джентльмены", "Все джентльмены за столом пьют."},
	{"Леди", "Все леди за столом пьют."},
	{"Тост", "Произносишь тост, все пьют."},
	{"Передай налево", "Игрок слева от тебя пьет."},
	{"Передай направо", "Игрок справа от тебя пьет."},
	{"Вызов", "Выбери игрока и выпей. Он должен выпить не меньше тебя."},
	{"Все на пол", "Все игроки должны коснуться пола. Последний пьет."},
	{"Прозвище", "Придумай прозвище игроку. Все должны звать его этим прозвищем до конца игры. Тот, кто обратился к нему иначе, пьет."},
	{"Твои правила", "Становишься Rulemaster'ом и придумываешь свои правила. Следующий Rulemaster может отменить правила предыдущего."},
	{"Секретная служба", "Все должны приложить ладонь к уху, изображая телохранителей. Последний становится президентом и пьет."},
	{"Брудершафт", "Выпей на брудершафт с игроком на выбор."},
	{"Шах и мат", "Выбери игрока, который будет пить с тобой каждый раз, когда ты ошибаешься."},
	{"Повтори за мной", "Просишь игрока повторить за тобой (скороговорку или сложнопроизносимое слово). Если у него не получилось - он пьет. Получилось - пьешь ты."},
	{"Неудобные вопросы", "Каждый игрок имеет право задать тебе любой вопрос. Если ты отказываешься на него отвечать - ты пьешь."},
	{"Нос", "Все игроки должны коснуться носа. Последний пьет."},
	{"Категория", "Вытянувший карту придумывает категорию (марки презервативов, музыкальные группы 90-х годов, модели Mercedes). Остальные игроки называют слова из этой категории. Кто не сможет - пьет."},
	{"Я никогда не", "Говоришь то, что ты \"Никогда не делал\" (но на самом деле делал или очень хотел бы). Тот, кто делал это, пьет."},
	{"Вопросы", "Игрок задает вопрос игроку слева. Отвечать на него нельзя, нужно быстро задать вопрос следующему соседу. Сбился? Ошибся? Запнулся? Выпей."},
	{"Цвет", "Игрок называет цвет, следующий повторяет его и добавляет свой, и так далее. Кто сбился, тот пьет."},
	{"Кубок", "Первые три игрока, вытянувшие эту карту, сливают содержимое своих бокалов в кубок. Четвертый это дело выпивает."},
	{"Саймон говорит", "Тот, кто вытянул эту карту делает какой-нибудь жест, следующий делает то же самое и добавляет свой. Так продолжается, пока кто-нибудь не собьется."},
	{"Товарищ заебал", "Игрок, вытянувший эту карту, становится товарищем. Другим игрокам нельзя отвечать на его вопросы."},
}

var decks map[int64][]*card = make(map[int64][]*card)

func createDeck() []*card {
	rand.Seed(time.Now().UnixNano())

	res := make([]*card, 0)
	for _, card := range cards {
		for i := 0; i < rand.Intn(5); i++ {
			res = append(res, card)
		}
	}

	rand.Shuffle(len(res), func(i, j int) {
		res[i], res[j] = res[j], res[i]
	})

	return res
}

func (z *zupabot) handleUpdate(update tgbotapi.Update) {
	chatID := update.Message.Chat.ID
	deck, exists := decks[chatID]
	if !exists {
		decks[chatID] = createDeck()
		deck = decks[chatID]
	}
	
	card:= deck[0]
	decks[chatID] = deck[1:]

	z.Send(tgbotapi.NewMessage(chatID, card.name))
}

func main() {
	config := config.GetConfig("godrunk.yaml")

	b, err := tgbotapi.NewBotAPI(config.Token)
	if err != nil {
		log.Panic(err)
	}
	bot := &zupabot{b}

	bot.Debug = true

	log.Printf("Authorized on account %s", bot.Self.UserName)

	webhookConfig := tgbotapi.NewWebhook(config.WebhookAddress)
	_, err = bot.SetWebhook(webhookConfig)
	if err != nil {
		log.Panic(err)
	}

	updates := bot.ListenForWebhook("/")
	go http.ListenAndServe(fmt.Sprintf(":%v", config.Port), nil)

	for update := range updates {
		bot.handleUpdate(update)
	}
}
